<theory-header chapterName="Interceptor" />
<section class="card-body">
	<article class="card">
		<div class="card-header">
			<h2>Http Interceptors</h2>
		</div>
		<div class="card-body">
			<p>
				Les <strong>Http Interceptors</strong> sont des classes qui interceptent chaque requÃªte HTTP sortante et la rÃ©ponse
				entrante. Ils sont souvent utilisÃ©s pour ajouter des en-tÃªtes comme les jetons d'authentification ou pour gÃ©rer les erreurs
				de maniÃ¨re globale.
			</p>
			<p>Pour crÃ©er un intercepteur, on peut utiliser la commande : <code>ng g interceptor chemin/de/mon/intercepteur</code></p>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>Exemple de Token Interceptor</h2>
		</div>
		<div class="card-body">
			<p>Le <code>TokenInterceptor</code> est un intercepteur qui ajoute un jeton d'authentification Ã  chaque requÃªte sortante.</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
import {HttpInterceptorFn} from '@angular/common/http';
import {AuthService} from '../services/auth.service';
import {inject} from '@angular/core';

export const jwtInterceptor: HttpInterceptorFn = (req, next) => {
  // injecter le service AuthService
  const authService: AuthService = inject(AuthService);

  // rÃ©cupÃ©rer le user du service AuthService
  const user = authService.currentUser();

  // vÃ©rifier si le user existe
  if (user) {
    // rajouter le access token du user dans la requÃªte
    const token = user.accessToken;

    // ajouter Authorization dans les headers
    const requestClone = req.clone({
      headers: req.headers.append('Authorization', 'Bearer ' + token),
    });

    // retourner la requÃªte clonÃ©e
    return next(requestClone);
  }

  return next(req);
};
			</textarea
			>
			<p>ğŸ” Analyse:</p>
			<ul>
				<li>
					Le service <code>AuthService</code> est injectÃ© dans l'intercepteur pour rÃ©cupÃ©rer le jeton d'accÃ¨s de l'utilisateur
					autorisÃ©e.
				</li>
				<li>
					La mÃ©thode <code>currentUser()</code> du service <code>AuthService</code> est utilisÃ©e pour obtenir l'utilisateur
					connectÃ©.
				</li>
				<li>
					Si l'utilisateur est connectÃ©, le jeton d'accÃ¨s est extrait et ajoutÃ© Ã  l'en-tÃªte de la requÃªte HTTP en utilisant la
					mÃ©thode <code>clone()</code> de l'objet <code>HttpRequest</code>.
				</li>
				<li>La mÃ©thode <code>next()</code> est appelÃ©e avec la requÃªte clonÃ©e pour continuer le traitement de la requÃªte.</li>
			</ul>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>Exemple de Error Interceptor</h2>
		</div>
		<div class="card-body">
			<p>
				Le <code>ErrorInterceptor</code> est un intercepteur qui gÃ¨re les erreurs HTTP et redirige le user vers les pages
				appropriÃ©es si nÃ©cessaire (page pour l'erreur 500, login...)
			</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
import { HttpInterceptorFn } from '@angular/common/http';
import {catchError, throwError} from 'rxjs';
import {Router} from '@angular/router';
import {inject} from '@angular/core';
import {AuthService} from '../services/auth.service';

export const errorInterceptor: HttpInterceptorFn = (req, next) => {
  const router:Router = inject(Router);
  const authService: AuthService = inject(AuthService);

  return next(req).pipe(
    catchError(error => {
      console.log(error);

      if(error.status === 401){
        // redirection vers auth/login
        authService.logout();
        router.navigate(['/auth/login']);
        return throwError(() => null);
      }
      /* si on avait une page d'erreur pour les problÃ¨mes serveur:
    else if(error.status === 500){
      router.navigate(['/error/server-error']);
      return throwError(() => null);
    }
     */

      /*
      switch (error.status){
        case 401:
          authService.logout();
          router.navigate(['/auth/login']);
          return throwError(() => null);
        case 500:
          router.navigate(['/error/server-error']);
          return throwError(() => null);
      }
      */

      return throwError(() => error);
    })
  );
};
			</textarea
			>
			<p>ğŸ” Analyse:</p>
			<ul>
				<li>Le service <code>Router</code> est injectÃ© dans l'intercepteur pour gÃ©rer la redirection en cas d'erreur.</li>
				<li>La mÃ©thode <code>catchError()</code> est utilisÃ©e pour intercepter les erreurs de la requÃªte HTTP.</li>
				<li>
					Si une erreur 401 (non autorisÃ©e) est rencontrÃ©e, l'utilisateur est redirigÃ© vers la page de connexion et le service
					<code>AuthService</code> est utilisÃ© pour se dÃ©connecter.
				</li>
				<li>
					Si une erreur 500 (erreur serveur) est rencontrÃ©e, l'utilisateur est redirigÃ© vers une page d'erreur spÃ©cifique. (Non
					implÃ©mentÃ© dans cet exemple)
				</li>
				<li>
					La mÃ©thode <code>throwError()</code> est utilisÃ©e pour renvoyer l'erreur au flux d'observation, permettant ainsi de
					gÃ©rer l'erreur dans le composant appelant.
				</li>
			</ul>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>Mise en place des interceptors</h2>
		</div>
		<div class="card-body">
			<p>
				Pour mettre en place les interceptors, il faut les dÃ©clarer dans le <code>app.config.ts</code> et modifier l'appel de
				<code>provideHttpClient</code>. En rajoutant <code>withInterceptors()</code> et en lui passant un tableau d'intercepteurs
				(prÃ©alablement coder).
			</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
provideHttpClient( withInterceptors( [ jwtInterceptor, errorInterceptor ] ) )
			</textarea
			>
		</div>
	</article>
</section>
